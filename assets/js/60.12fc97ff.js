(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{376:function(a,t,e){"use strict";e.r(t);var r=e(18),o=function(a){a.options.__data__block__={mermaid_382ee226:"sequenceDiagram\n  participant a as User\n  participant b as Blob Storage\n  participant c as CKAN\n  participant d as Loader\n  participant e as DataStore\n  \n  a->>c: create a resource with a location of remote file\n  c->>d: push notification\n  d->>b: pull it\n  d->>e: push it\n  d--\x3e>c: success (or failure) notification\n",mermaid_382ee242:"sequenceDiagram\n  participant a as User\n  participant b as Blob Storage\n  participant c as CKAN\n  participant d as Loader\n  participant e as DataStore\n  \n  a->>c: click on upload button\n  c->>d: push notification\n  d->>b: pull it\n  d->>e: push it\n  d--\x3e>c: success (or failure) notification\n",mermaid_64a56fa8:'graph TD\n\ndatastore[Datastore API]\ndatapusher[DataPusher]\npg[Postgres DB]\nfilestore[File Store]\nxloader[XLoader]\n\nfilestore --"Tabular data"--\x3e datapusher\ndatapusher --\x3e datastore\ndatastore --\x3e pg\n\nfilestore -. or via .-> xloader\nxloader --\x3e pg\n',mermaid_64a56f76:"sequenceDiagram\n    Publisher->>CKAN Instance: Add tabular resource from disk or URL\n    CKAN Instance--\x3e>FileStore: Upload data to storage\n    CKAN Instance--\x3e>Datapusher: Add job to queue\n    Datapusher--\x3e>Datastore: Run the job\n    Datastore--\x3e>Postgres: Create table per resource and insert data\n"}},s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"data-load"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#data-load"}},[a._v("#")]),a._v(" Data Load")]),a._v(" "),e("h2",{attrs:{id:"introduction"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[a._v("#")]),a._v(" Introduction")]),a._v(" "),e("p",[a._v("Data load covers functionality for automatedly loading structured data such as tables into a data management system. Data load is usually part of a larger "),e("RouterLink",{attrs:{to:"/data-api/"}},[a._v("Data API (DataStore)")]),a._v(" component.")],1),a._v(" "),e("p",[a._v("Load is distinct from uploading raw files (“blobs”) and from a “write” data API: from blobs because the data is structured (e.g. rows and columns) and that structure is expected to be preserved; from a write data API because the data is imported in bulk (e.g. a whole CSV file) rather than writing one row at a time.")]),a._v(" "),e("p",[a._v("The load terminology comes from ETL (extract, transform, load) though in reality this functionality will often include some extraction and transformation – extracting the structured data from the source formats and potentially transformation if data needs some cleaning.")]),a._v(" "),e("h3",{attrs:{id:"features"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#features"}},[a._v("#")]),a._v(" Features")]),a._v(" "),e("p",[a._v("As a Publisher i want to load my dataset (resource) into the DataStore quickly and reliably so that my data is available over the data API.")]),a._v(" "),e("ul",[e("li",[a._v("Be “tolerant” where possible of bad data so that it still loads")]),a._v(" "),e("li",[a._v("Get feedback on load progress, especially if something went wrong (with info on how I can fix it), so that I know my data is loaded (or if not what I can do about it)")]),a._v(" "),e("li",[a._v("I want to update the schema for the data so that the data has right types (before and/or after load)")]),a._v(" "),e("li",[a._v("I want to be able to update with a new resource file and only have it load the most recent")])]),a._v(" "),e("p",[a._v("For sysadmins:")]),a._v(" "),e("ul",[e("li",[a._v("Track Performance: As a Datopian Cloud Sysadmin I want to know if there are issues so that I can promptly address any problems for clients")]),a._v(" "),e("li",[a._v("One Data Load Service per Cloud: As a Datopian Cloud Manager I may want to have one “DataLoad” service I maintain rather than one per instance for efficiency …")])]),a._v(" "),e("h3",{attrs:{id:"flows"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flows"}},[a._v("#")]),a._v(" Flows")]),a._v(" "),e("h4",{attrs:{id:"automatic-load"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#automatic-load"}},[a._v("#")]),a._v(" Automatic load")]),a._v(" "),e("ul",[e("li",[a._v("Users uploads a file to portal using the Dataset editor\n"),e("ul",[e("li",[a._v("This is stored into the blob storage (i.e. local or cloud storage)")])])]),a._v(" "),e("li",[a._v("A “PUSH” notification is triggered to loader service")]),a._v(" "),e("li",[a._v("Loader service load file to data API backend (a structured database with web API)")])]),a._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee226",graph:a.$dataBlock.mermaid_382ee226}}),e("h4",{attrs:{id:"sequence-diagram-for-manual-load"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sequence-diagram-for-manual-load"}},[a._v("#")]),a._v(" Sequence diagram for manual load")]),a._v(" "),e("p",[a._v("The load to the data API system can also be triggered manually:")]),a._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee242",graph:a.$dataBlock.mermaid_382ee242}}),e("h2",{attrs:{id:"ckan-v2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ckan-v2"}},[a._v("#")]),a._v(" CKAN v2")]),a._v(" "),e("p",[a._v("Provided by either DataPusher or XLoader.")]),a._v(" "),e("h3",{attrs:{id:"datapusher"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#datapusher"}},[a._v("#")]),a._v(" DataPusher")]),a._v(" "),e("p",[a._v("Service (API) For pushing tabular data to datastore. Do not confuse it with "),e("code",[a._v("ckanext/datapusher")]),a._v(" in ckan core codbase which is simply an extension communicating with the DataPusher API. DataPusher itself is a standalone service, running separately from CKAN app.")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/ckan/datapusher",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/ckan/datapusher"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://docs.ckan.org/projects/datapusher/en/latest/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://docs.ckan.org/projects/datapusher/en/latest/"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://docs.ckan.org/en/2.8/maintaining/datastore.html#datapusher-automatically-add-data-to-the-datastore",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://docs.ckan.org/en/2.8/maintaining/datastore.html#datapusher-automatically-add-data-to-the-datastore"),e("OutboundLink")],1)]),a._v(" "),e("h3",{attrs:{id:"xloader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xloader"}},[a._v("#")]),a._v(" XLoader")]),a._v(" "),e("p",[a._v("XLoader runs as async jobs within CKAN and bulk loads data via Postgres COPY command. This is fast but it does mean it only loads data as strings and explicit type-casting must be done after the load (the user must edit the data dictionary). XLoader was built to address 2 major issues with DataPusher:")]),a._v(" "),e("ul",[e("li",[a._v("Speed: DataPusher converts data row by row and writes over the DataStore write API and hence is quite slow.")]),a._v(" "),e("li",[a._v("Dirty data: DataPusher attempts to guess data types and then cast and this regularly led to failures which though logical were frustrating to users. XLoader gets the data in (as strings) and let’s the user sort out types later.")])]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/ckan/ckanext-xloader",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/ckan/ckanext-xloader"),e("OutboundLink")],1)]),a._v(" "),e("ul",[e("li",[e("code",[a._v("load_csv")]),a._v(": "),e("a",{attrs:{href:"https://github.com/ckan/ckanext-xloader/blob/master/ckanext/xloader/loader.py#L40",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/ckan/ckanext-xloader/blob/master/ckanext/xloader/loader.py#L40"),e("OutboundLink")],1)]),a._v(" "),e("li",[a._v("Loader: "),e("a",{attrs:{href:"https://github.com/ckan/ckanext-xloader/blob/master/ckanext/xloader/jobs.py#L100",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/ckan/ckanext-xloader/blob/master/ckanext/xloader/jobs.py#L100"),e("OutboundLink")],1)])]),a._v(" "),e("p",[a._v("How does the queue system work: job queue is done by RQ, which is simpler and is backed by Redis and allows access to the CKAN model. Job results are currently still stored in its own database, but the intention is to move this relatively small amount of data into CKAN’s database, to reduce the complication of install.")]),a._v(" "),e("h3",{attrs:{id:"flow-of-data-in-data-load"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flow-of-data-in-data-load"}},[a._v("#")]),a._v(" Flow of Data in Data Load")]),a._v(" "),e("Mermaid",{attrs:{id:"mermaid_64a56fa8",graph:a.$dataBlock.mermaid_64a56fa8}}),e("p",[a._v("Sequence diagram showing the journey of a tabular file into the DataStore:")]),a._v(" "),e("Mermaid",{attrs:{id:"mermaid_64a56f76",graph:a.$dataBlock.mermaid_64a56f76}}),e("h3",{attrs:{id:"faqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#faqs"}},[a._v("#")]),a._v(" FAQs")]),a._v(" "),e("p",[a._v("Q: What happens with non-tabular data?"),e("br"),a._v("\nA: CKAN has a list of types of data it can process into the DataStore (TODO:link) and will only process those.")]),a._v(" "),e("h3",{attrs:{id:"what-issues-are-there"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#what-issues-are-there"}},[a._v("#")]),a._v(" What Issues are there?")]),a._v(" "),e("p",[a._v("Generally: the Data Load system is an hand-crafted, bespoke mini-ETL process. It would seem better to use high-quality third-party ETL tooling here rather than hand-roll be that for pipeline creation, monitoring, orchestration etc.")]),a._v(" "),e("p",[a._v("Specific examples:")]),a._v(" "),e("ul",[e("li",[a._v("No connection between DataStore system and CKAN validation extension powered by GoodTables "),e("a",{attrs:{href:"https://github.com/frictionlessdata/ckanext-validation",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/frictionlessdata/ckanext-validation"),e("OutboundLink")],1),a._v(" Thus, for example, users may edit the DataStore Data Dictionary and be confused that this has no impact on validation. More generally, data validation and data loading might naturally be part of one overall ETL process but Data Load system is not architected in a way that makes this easy to add.")]),a._v(" "),e("li",[a._v("No support for Frictionless Data spec sand their ability to specific incoming data structure (CSV format, encoding, column types etc).\n"),e("ul",[e("li",[a._v("Dependent on error-prone guessing of types or manual type conversion")]),a._v(" "),e("li",[a._v("Makes it painful to integrate with broader data processing pipeline (e.g. clean separation would allow type guessing to be optimized elsewhere in another part of the ETL pipeline)")])])]),a._v(" "),e("li",[a._v("Excel loading won’t work or won’t load all sheets")]),a._v(" "),e("li",[a._v("DataPusher\n"),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/ckan/ckanext-xloader#key-differences-from-datapusher",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/ckan/ckanext-xloader#key-differences-from-datapusher"),e("OutboundLink")],1)]),a._v(" "),e("li",[a._v("Works terribly with loading a bit big data. It may for no reason crash after hour of loading. And after reload it goes along")]),a._v(" "),e("li",[a._v("Is slow esp for large datasets and even smallish datasets e.g. 25Mb")]),a._v(" "),e("li",[a._v("often fails due to e.g. data validation/casting errors but this not clear (and unsatisfying to the user)")])])]),a._v(" "),e("li",[a._v("XLoader:\n"),e("ul",[e("li",[a._v("Doesn’t work with XLS(X)")]),a._v(" "),e("li",[a._v("has problems fetching resources from Blob Storage (it fails and need to wait until the Resource is uploaded.)")]),a._v(" "),e("li",[a._v("raising Exception NotFound when CKAN has a delay creating resources")]),a._v(" "),e("li",[a._v("re-submits Resources when creating a new Resource")]),a._v(" "),e("li",[a._v("XLoader sets "),e("code",[a._v("datastore_active")]),a._v(" before data is uploaded")])])])]),a._v(" "),e("h2",{attrs:{id:"ckan-v3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ckan-v3"}},[a._v("#")]),a._v(" CKAN v3")]),a._v(" "),e("p",[a._v("The v3 implementation is named 💨🥫 AirCan: "),e("a",{attrs:{href:"https://github.com/datopian/aircan",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/datopian/aircan"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("Its a lightweight, standalone service using AirFlow.")]),a._v(" "),e("p",[a._v("Status: Beta (June 2020)")]),a._v(" "),e("ul",[e("li",[a._v("Runs as a separate microservice with zero coupling with CKAN core (=> gives cleaner separation and testing)")]),a._v(" "),e("li",[a._v("Uses Frictionless Data patterns and specs where possible e.g. Table Schema for describing or inferring the data schema")]),a._v(" "),e("li",[a._v("Uses AirFlow as the runner")]),a._v(" "),e("li",[a._v("Uses common ETL / "),e("RouterLink",{attrs:{to:"/flows/"}},[a._v("Data Flows")]),a._v(" patterns and frameworks")],1)]),a._v(" "),e("h3",{attrs:{id:"design"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[a._v("#")]),a._v(" Design")]),a._v(" "),e("p",[a._v("See "),e("RouterLink",{attrs:{to:"/load/design/"}},[a._v("Design page »")])],1)],1)}),[],!1,null,null,null);"function"==typeof o&&o(s);t.default=s.exports}}]);