(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{361:function(e,t,a){"use strict";a.r(t);var o=a(18),s=function(e){e.options.__data__block__={mermaid_382ee222:"sequenceDiagram\n\nparticipant Browser as Client (Browser / Code)\nparticipant Authz as Authz Server\nparticipant BitStore as Storage Access Token Service\nparticipant Storage as Cloud Storage\n\n  Browser->>Authz: Give me a BitStore access token\n  Authz->>Browser: Token\n  Browser->>BitStore: Get a signed upload URL (access token, file metdata)\n  BitStore->>Browser: Signed URL\n  Browser->>Storage: Upload file (signed URL)\n  Storage->>Browser: OK (storage metadata)\n",mermaid_382ee226:"sequenceDiagram\n\n  participant browser as Client (Browser / Code)\n  participant vfts as MetaStore\n  participant bitstore as Storage Access Token Service\n  participant storage as Cloud Storage\n  \n  browser->>browser: Select files to upload\n  browser->>browser: calculate file hashes (if doing content addressable)\n  browser->bitstore: get signed URLs(file1.csv URL, file2.csv URL, auth info)\n  bitstore->>browser: signed URLs\n  browser->>storage: upload file1.csv\n  storage->>browser: OK\n  browser->>storage: upload file2.csv\n  storage->>browser: OK\n  browser->>browser: Compose datapackage.json\n  browser->>vfts: create dataset(datapackage.json, file1.csv pointer, file2.csv pointer, jwt token, ...)\n  vfts->>browser: OK\n"}},i=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"blob-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blob-storage"}},[e._v("#")]),e._v(" Blob Storage")]),e._v(" "),a("h2",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),a("p",[e._v("DMS and data portals often need to "),a("em",[e._v("store")]),e._v(" data as well as metadata. As such, they require a system for doing this. This page focuses on Blob Storage aka Bulk or Raw storage (see "),a("RouterLink",{attrs:{to:"/storage/"}},[e._v("storage")]),e._v(" page for an overview of all types of storage).")],1),e._v(" "),a("p",[e._v("Blob storage is for storing “blobs” of data, that is a raw stream of bytes like files on a filesystem. For blob storage think local filesystem or cloud storage like S3, GCS, etc.")]),e._v(" "),a("p",[e._v("Blob Storage in a DMS can be provided via:")]),e._v(" "),a("ul",[a("li",[e._v("Local file system: storing on disk or storage directly connected to the instance")]),e._v(" "),a("li",[e._v("Cloud storage like S3, Google Cloud Storage, Azure storage etc")])]),e._v(" "),a("p",[e._v("Today, cloud storage would be the default in most cases.")]),e._v(" "),a("h3",{attrs:{id:"features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#features"}},[e._v("#")]),e._v(" Features")]),e._v(" "),a("ul",[a("li",[e._v("Storage: Persistent, cost-efficient storage")]),e._v(" "),a("li",[e._v("Download: Fast, reliable download (possibly even with support for edge distribution)")]),e._v(" "),a("li",[e._v("Upload: reliable and rapid upload\n"),a("ul",[a("li",[e._v("Direct upload to (cloud) storage by clients i.e. without going via the DMS. Why? Because cloud storage has many features that it would be costly replicate (e.g. multipart, resumable etc), excellent performance and reliability for upload. It also cuts out the middleman of the DMS backend thereby saving bandwidth, reducing load on the DMS backend and improving performance")]),e._v(" "),a("li",[e._v("Upload UI: having an excellent UI for doing upload. NB: this UI is considered part of the "),a("RouterLink",{attrs:{to:"/publish/"}},[e._v("publish feature")])],1)])]),e._v(" "),a("li",[e._v("Cloud: integrate with cloud storage")]),e._v(" "),a("li",[e._v("Permissions: restricting access to data stored in blob storage based on the permissions of the DMS. For example, if Joe does not have access to a dataset on the DMS he should not be able to access associated blob data in the storage system")])]),e._v(" "),a("h2",{attrs:{id:"flows"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flows"}},[e._v("#")]),e._v(" Flows")]),e._v(" "),a("h3",{attrs:{id:"direct-to-cloud-upload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#direct-to-cloud-upload"}},[e._v("#")]),e._v(" Direct to Cloud Upload")]),e._v(" "),a("p",[e._v("Want: Direct upload to cloud storage … But you need to authorize that … So give them a token from your app")]),e._v(" "),a("p",[e._v("A sequence diagram illustrating the process for a direct to cloud upload:")]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_382ee222",graph:e.$dataBlock.mermaid_382ee222}}),a("p",[e._v("Here’s a more elaborate version showing storage of metadata into the MetaStore afterwards (and skipping the Authz service):")]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_382ee226",graph:e.$dataBlock.mermaid_382ee226}}),a("h2",{attrs:{id:"ckan-2-classic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ckan-2-classic"}},[e._v("#")]),e._v(" CKAN 2 (Classic)")]),e._v(" "),a("p",[e._v("Blob Storage is known as the FileStore in CKAN v2 and below. The default is local disk storage.")]),e._v(" "),a("p",[e._v("There is support for cloud storage via a variety of extensions the most prominent of which is "),a("code",[e._v("ckanext-cloudstorage")]),e._v(": "),a("a",{attrs:{href:"https://github.com/TkTech/ckanext-cloudstorage",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/TkTech/ckanext-cloudstorage"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("There are a variety of issues:")]),e._v(" "),a("ul",[a("li",[e._v("Cloud storage is not a first class citizen in CKAN: CKAN defaults to local file storage but cloud storage is the default in the world and has much better scalability, performance as well as integratability with cloud deployment")]),e._v(" "),a("li",[e._v("The FileStore interface definition has a poor separation of concerns (for example, blob storage file paths is set in the FileStore component not in core CKAN) which makes it hard / hacky to extend and use for key use cases e.g. versioning.")]),e._v(" "),a("li",[a("code",[e._v("ckanext-cloudstorage")]),e._v(" (the default cloud storage extension) is ok but has many issues e.g.\n"),a("ul",[a("li",[e._v("No direct to cloud upload: it uses CKAN backend as a middleman so all data must go via ckan backend")]),e._v(" "),a("li",[e._v("Implements its own (sometimes unreliable) version of multipart upload (which means additional code which isn’t as reliable as cloud storage providers interface)")]),e._v(" "),a("li",[e._v("No access to advanced features such as resumability etc")])])])]),e._v(" "),a("p",[e._v("Generally, we at Datopian have seen a lot of issues around multipart / large file upload stability with clients and are still seeing issues when a lot of large files are uploaded via scripts. Fixing and refactoring code related to storage is very costly, and tends to result in client specific “hacks”.")]),e._v(" "),a("h2",{attrs:{id:"ckan-3-next-gen"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ckan-3-next-gen"}},[e._v("#")]),e._v(" CKAN 3 (Next Gen)")]),e._v(" "),a("p",[e._v("We have built a new cloud-native storage implementation which is backwards compatible with CKAN v2. It is designed as microservice and supports direct to cloud uploads and downloads.")]),e._v(" "),a("p",[e._v("Status: Production.")]),e._v(" "),a("p",[e._v("CKAN v2 extension: "),a("a",{attrs:{href:"https://github.com/datopian/ckanext-external-storage",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/datopian/ckanext-external-storage"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Subcomponents:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/datopian/giftless",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/datopian/giftless"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/datopian/ckanext-authz-service",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/datopian/ckanext-authz-service"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("You can read more about it in the design goals section below.")]),e._v(" "),a("h2",{attrs:{id:"design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[e._v("#")]),e._v(" Design")]),e._v(" "),a("h3",{attrs:{id:"purpose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purpose"}},[e._v("#")]),e._v(" Purpose")]),e._v(" "),a("p",[e._v("The goal of this project is to create a more "),a("strong",[a("em",[e._v("flexible")])]),e._v(" system for storing "),a("strong",[a("em",[e._v("data files")])]),e._v(" (AKA “resources”) for "),a("strong",[a("em",[e._v("CKAN")]),e._v(" and "),a("em",[e._v("other implementations")])]),e._v(" of a data portal so that CKAN can support versioning, large file upload (and great file upload UX), plug easily into cloud and local file storage backends and, in general, is easy to customize both for storage layer and for CKAN client code of that layer")]),e._v(" "),a("h3",{attrs:{id:"features-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#features-2"}},[e._v("#")]),e._v(" Features")]),e._v(" "),a("ul",[a("li",[e._v("Do one thing and do it well: provide an API to store and retrieve files from storage, in a way that is pluggable into a micro-services based application and to existing CKAN (2.8 / 2.9)")]),e._v(" "),a("li",[e._v("Does not force, and in fact is not aware of, a specific file naming logic (i.e. resource file names could be based on a user given name, a content hash, a revision ID or any mixture of these - it is up to the using system to decide)")]),e._v(" "),a("li",[e._v("Does not force a specific storage backend; Should support Amazon S3, Azure Storage and local file storage in some way initially but in general backend should be pluggable")]),e._v(" "),a("li",[e._v("Does not force a specific authentication scheme; Expects a signed JWT token, does not care who signed it and how the user got authenticated")]),e._v(" "),a("li",[e._v("Does not force complex authorization scheme; Leave it to external system to do complex authorization if needed;\n"),a("ul",[a("li",[e._v("By default, the system can work in an “admin party” mode where all authenticated users have full access to all files. This will be “good enough” for many DMS implementations including CKAN.")]),e._v(" "),a("li",[e._v("Potentially, allow plugging in a more complex authorization logic that relies on JWT claims to perform granular authorization checks")])])])]),e._v(" "),a("h3",{attrs:{id:"for-data-files-i-e-blobs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-data-files-i-e-blobs"}},[e._v("#")]),e._v(" For Data Files (i.e. Blobs)")]),e._v(" "),a("p",[e._v("This system is about storing and providing access to blobs, or streams of bytes; It is not about providing access to the data stored within (i.e. it is not meant to replace CKAN’s datastore).")]),e._v(" "),a("h3",{attrs:{id:"for-ckan-whilst-not-necessarily-ckan-specific"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-ckan-whilst-not-necessarily-ckan-specific"}},[e._v("#")]),e._v(" For CKAN – whilst not necessarily CKAN Specific")]),e._v(" "),a("p",[e._v("While the system’s design should not be CKAN specific in any way, our current client needs require us to provide a CKAN extension that integrates with this system.")]),e._v(" "),a("p",[e._v("CKAN’s current IUploader interface has been identified to be too narrow to provide the functionality required by complex projects (resource versioning, direct cloud uploads and downloads, large file support and multipart support). While some of these needs could be and have been “hacked” through the IUploader interface, the implementations have been over complex and hard to debug.")]),e._v(" "),a("p",[e._v("Our goal should be to provide a CKAN extension that provides the following functionality directly:")]),e._v(" "),a("ul",[a("li",[e._v("Uploading and downloading resource files directly from the client if supported by the storage backend\n"),a("ul",[a("li",[e._v("Multipart upload support if supported by storage backend")]),e._v(" "),a("li",[e._v("Handling of signed URLs for uploads and private downloads")]),e._v(" "),a("li",[e._v("Client side code for handling multipart uploads")]),e._v(" "),a("li",[e._v("TBD: If storage backend does not support direct uploads / downloads, fall back to …")])])])]),e._v(" "),a("p",[e._v("In addition, this extension should provide an API for other extensions to do things like:")]),e._v(" "),a("ul",[a("li",[e._v("Set the file naming scheme (We need this for ckanext-versions)")]),e._v(" "),a("li",[e._v("Lower level file access, e.g. move and delete files. We may need this in the future to optimize storage and deduplicate files as proposed for ckanext-versions")])]),e._v(" "),a("p",[e._v("In addition, this extension must “play nice” with common CKAN features such as the datastore extension and related datapusher / xloader extensions.")]),e._v(" "),a("h3",{attrs:{id:"usable-for-other-dms-implementations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usable-for-other-dms-implementations"}},[e._v("#")]),e._v(" Usable For other DMS implementations")]),e._v(" "),a("p",[e._v("There should be nothing in this system, except for the CKAN extension described above, that is specific to CKAN. That will allow to re-use and re-integrate this system as a micro-service in other DMS implementations such as ckan-ng and others."),a("br"),e._v("\nIn fact, the core part of this system should be a generic, abstract storage service with a light authorization layer. This could make it useful in a host of situations where storage micro-service is needed.")]),e._v(" "),a("h3",{attrs:{id:"high-level-principles"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#high-level-principles"}},[e._v("#")]),e._v(" High Level Principles")]),e._v(" "),a("p",[e._v("Common Principles")]),e._v(" "),a("ul",[a("li",[e._v("Uploads and downloads directly from cloud provides to browser")]),e._v(" "),a("li",[e._v("Signed uploads / downloads - for private / authorized only data access")]),e._v(" "),a("li",[e._v("Support for AWS, Azure and potentially GCP storage")]),e._v(" "),a("li",[e._v("Support for local (non cloud) storage, potentially through a system like "),a("a",{attrs:{href:"https://min.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://min.io/"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Multipart / large file upload support (a few GB in size should be supported for Gates)")]),e._v(" "),a("li",[e._v("Not opinionated about file naming / paths; Allow users to set file locations under some pre-defined patchs / buckets")]),e._v(" "),a("li",[e._v("Client side support - browser widgets / code for uploading and downloading files / multipart uploads directly to different backends")]),e._v(" "),a("li",[e._v("Well-documented flow for using from API (not browser)")]),e._v(" "),a("li",[e._v("Provided API for deleting and moving files")]),e._v(" "),a("li",[e._v("Provided API for accessing storage-level metadata (e.g. file MD5) (do we need this could be useful for processes that do things like deduplicate storage)")]),e._v(" "),a("li",[e._v("Provided API for managing storage-level object level settings (e.g. “Content-disposition” / “Content-type” headers, etc.)")]),e._v(" "),a("li",[e._v("Authorization based on some kind of portable scheme (JWT)")])]),e._v(" "),a("p",[e._v("CKAN integration specific (implemented as a CKAN extension)")]),e._v(" "),a("ul",[a("li",[e._v("JWT generation based on current CKAN user permissions")]),e._v(" "),a("li",[e._v("Client widgets integration (or CKAN specific widgets) in right places in CKAN templates")]),e._v(" "),a("li",[e._v("Hook into resource upload / download / deletion controllers in CKAN")]),e._v(" "),a("li",[e._v("API to allow other extensions to control storage level object metadata (headers, path)")]),e._v(" "),a("li",[e._v("API to allow other extensions to hook into lifecycle events - upload completion, download request, deletion etc.")])]),e._v(" "),a("h3",{attrs:{id:"components"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#components"}},[e._v("#")]),e._v(" Components")]),e._v(" "),a("p",[e._v("The Decoupled Storage solution should be split into several parts, with some parts being independent of others:")]),e._v(" "),a("ul",[a("li",[e._v("[External] Cloud Storage service (or API similar if local file system) e.g. S3, GCS, Azure Storage, "),a("a",{attrs:{href:"http://Min.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("Min.io"),a("OutboundLink")],1),e._v(" (for local file system)")]),e._v(" "),a("li",[e._v("Cloud Storage Access Service")]),e._v(" "),a("li",[e._v("[External] Permissions Service for granting general permission tokens that give access to Cloud Storage Access Service\n"),a("ul",[a("li",[e._v("JWT tokens can be generated by any party that has the right signing key. Thus, we can initially do without this if JWT signing is implemented as part of the CKAN extension")])])]),e._v(" "),a("li",[e._v("Browser based Client for Cloud Storage (compatible with #1 and with different cloud vendors)")]),e._v(" "),a("li",[e._v("CKAN extension that wraps the two parts above to provide a storage solution for CKAN")])]),e._v(" "),a("h3",{attrs:{id:"questions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#questions"}},[e._v("#")]),e._v(" Questions")]),e._v(" "),a("ul",[a("li",[e._v("What is file structure in cloud … i.e. What is the file path for uploaded files? Options:\n"),a("ul",[a("li",[e._v("Client chooses a name/path")]),e._v(" "),a("li",[e._v("Content addressable i.e. the name is given by the content? How? Use a hash.]\n"),a("ul",[a("li",[e._v("Beauty of that: standard way to name things. The same thing has the same name (modulo collisions)")]),e._v(" "),a("li",[e._v("Goes with versioning => same file = same name, diff file = diff name")])])])])]),e._v(" "),a("li",[e._v("And do you enforce that from your app\n"),a("ul",[a("li",[e._v("Request for token needs to include the destination file path")])])])])],1)}),[],!1,null,null,null);"function"==typeof s&&s(i);t.default=i.exports}}]);